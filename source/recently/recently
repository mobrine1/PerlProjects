#!/usr/bin/env perl
#cito M:755 O:0 G:0 T:/usr/bin/recently
#------------------------------------------------------------------------------
# Project Name      - PerlProjects/source/recently/recently
# Started On        - Sat 27 Feb 17:43:17 GMT 2021
# Last Change       - Mon  1 Mar 18:00:00 GMT 2021
# Author E-Mail     - terminalforlife@yahoo.com
# Author GitHub     - https://github.com/terminalforlife
#------------------------------------------------------------------------------
# This Perl tool was created as a fast and efficient workaround for this issue:
#
#   https://forums.linuxmint.com/viewtopic.php?f=47&t=343239
#
# Thanks to LMSF user 'Welcome' for inspiring me to write this, and making
# suggestions which ultimately led to its improvements.
#
# Features:
#
#TODO: Have number OPT affect `$List` functionality, too.
#TODO: Daemonize, executing when file change detected.
#TODO: Trap signals.
#TODO: Quit main loop when file checks fail.
#TODO: Handle re-execution, when daemonized.
#
# Bugs:
#
# N/A
#
# Dependencies:
#
#   libwww-form-urlencoded-perl (>= 0.24-1)
#   perl (>= 5.22.1-9)
#------------------------------------------------------------------------------

require WWW::Form::UrlEncoded;

use v5.22.1;
use strict;
use warnings;
use autodie;

no warnings 'uninitialized';

my $CurVer = '2021-03-01';
my $Progrm = 'recently';
my $ProgrmFancy = 'Recently';

sub Usage {
	print(qq{Usage: $Progrm [OPTS]

		  -h, --help               - Display this help information.
		  -v, --version            - Output the version datestamp.
		  -B, --no-backup          - Don't create backup before writing.
		  -f, --file [FILE]        - Use FILE instead of the default.
		  -n, --number [INT]       - Keep INT number of bookmarks.
		  -o, --output             - Just ouput the resulting XML data.
		  -r, --raw                - When listing, display the raw URI.
		  -w, --write              - Write bookmark changes to disk.

		  Unless otherwise specified, the following FILE is used:

		    ~/.local/share/recently-used.xbel

		  By default, 10 bookmarks will be kept, and a backup of FILE will be
		  created. If not writing or sending the changes to STDOUT, all URIs
		  (IE: 'file://') will be listed, in order of appearance.
	} =~ tr/\t//dr)
}

my $BackUp = 1;
my $Last = 10;
my $List = 1;
my $Output = 0;
my $RawURI = 0;
my $Write = 0;

my $File = "$ENV{HOME}/.local/share/recently-used.xbel";

my ($WriteFlag, $NumberFlag, $NoBackUpFlag, $RawURIFlag);
while (defined($ARGV[0])) {
	if ($ARGV[0] =~ '^(--help|-h)$') {
		Usage(); exit(0)
	} elsif ($ARGV[0] =~ '^(--version|-v)$') {
		print("$CurVer\n"); exit(0)
	} elsif ($ARGV[0] =~ '^(--write|-w)$') {
		$WriteFlag = $ARGV[0];

		$Write = 1
	} elsif ($ARGV[0] =~ '^(--file|-f)$') {
		if (length($ARGV[1]) == 0) {
			die("OPT '$ARGV[0]' requires an argument")
		} elsif (not -f $ARGV[1]) {
			die("File '$ARGV[1]' not found")
		} else {
			$File = $ARGV[1];
			shift()
		}
	} elsif ($ARGV[0] =~ '^(--number|-n)$') {
		$NumberFlag = $ARGV[0];

		if (length($ARGV[1]) == 0) {
			die("OPT '$ARGV[0]' requires an argument")
		} elsif ($ARGV[1] !~ '^[[:digit:]]+$') {
			die("Invalid number of bookmarks")
		} else {
			$Last = $ARGV[1];
			shift()
		}
	} elsif ($ARGV[0] =~ '^(--no-backup|-B)$') {
		$NoBackUpFlag = $ARGV[0];

		$BackUp = 0
	} elsif ($ARGV[0] =~ '^(--raw|-r)$') {
		$RawURIFlag = $ARGV[0];

		$RawURI = 1
	} elsif ($ARGV[0] =~ '^(--output|-o)$') {
		$Output = 1
	} else {
		die("Incorrect option(s) specified")
	}

	shift()
}

if ($Write and $RawURI) {
	die("Incompatible OPTs '$WriteFlag' and '$RawURIFlag'");
} elsif (not $Write and not $BackUp) {
	die("Using '$NoBackUpFlag' without writing changes");
} elsif ($NumberFlag and (not $Write and not $Output)) {
	die("Unpaired '$NumberFlag' OPT");
}

# Clean-up on aisle three.
map(undef($_), ($NumberFlag, $NoBackUpFlag, $RawURIFlag, $WriteFlag));

-f $File or die("File '$File' missing");
-r $File or die("File '$File' unreadable");
-w $File or die("File '$File' unwritable");

#----------------------------------------------------------------Parse XML File

my (@Files, %Bookmarks, @CurrentBM, @WantedLines, @Buffer);
my $REGEX = '^[\t\s]*<bookmark href="(.*)"\sadded="(.*)"\smodified=';
if (open(my $FH, '<', $File)) {
	# Confirm it's a UTF-8, version 1 XML XBEL file.
	if (<$FH> !~ m/^<\?xml version="1\.0" encoding="UTF-8"\?>/i) {
		die("File '$File' is not XML");
	} elsif (<$FH> !~ m/^<xbel version="1.0"$/i) {
		die("File '$File' is not XBEL");
	}

	seek($FH, 0, 0);
	@Buffer = <$FH>;

	my $Added;
	my $Found = 0;
	my $LineCount = 0;
	foreach my $Line (@Buffer) {
		$LineCount++;

		if ($Line =~ m/$REGEX/) {
			# We're now within a bookmark tag.
			push(@CurrentBM, $Line);
			push(@Files, $1);
			$Added = $2;

			$Found = 1
		} elsif ($Found) {
			# Handle the lines within the current bookmark tags.
			if ($Line =~ '^[\t\s]*</bookmark>$') {
				push(@CurrentBM, $Line);
				$Bookmarks{$Added} = join('', @CurrentBM);
				undef(@CurrentBM);

				$Found = 0
			} else {
				# These are in-between the opening and closing bookmark tags.
				push(@CurrentBM, $Line)
			}
		} else {
			# Manually pushing the final line later on.
			unless ($LineCount == scalar(@Buffer)) {
				push(@WantedLines, $Line)
			}
		}
	}

	close($FH)
}

#---------------------------------------------------List & Parse Bookmark Files

if ($List and not ($Write or $Output)) {
	if (scalar(@Files) > 0) {
		if ($RawURI) {
			map(print("$_\n"), @Files)
		} else {
			use WWW::Form::UrlEncoded 'parse_urlencoded';

			# Decode the URL-encoded (IE: '%20' is ' ') strings.
			foreach (@Files) {
				my $File = join('', parse_urlencoded($_));
				print($File =~ s/^file:\/\///r . "\n")
			}
		}
	} else {
		print("No bookmarks found.\n");
		exit(2)
	}

	exit(0) unless $Write or $Output
}

#----------------------------------------Sort Bookmarks & Use Desired Bookmarks

my $Count = 0;
foreach (sort({$b cmp $a} keys(%Bookmarks))) {
	if (++$Count == $Last + 1) {
		last
	} elsif ($Count <= $Last) {
		# These are the lines for each bookmark we want, in order.
		push(@WantedLines, $Bookmarks{$_});
	}
}

push(@WantedLines, "</xbel>\n");

#----------------------------------------------------Save and/or Output Changes

$Output and map(print($_), @WantedLines);
exit(0) unless $Write;

if ($BackUp) {
	if (open(my $FH, '>', "$File.bak")) {
		print($FH @Buffer);
		close($FH);
	} else {
		die("Failed to create backup of FILE")
	}
}

open(my $FH, '>', $File);
map(print($FH $_), @WantedLines);
close($FH)
